////////////////////////////////////////////////////////////////////////////////
export async function rysinDict2Json(readline, output) {
  return new Promise(resolve => {
    let lemmata = {};
    let lemmataIdGenerator = 0;
    let tags = {};
    let tagsIdGenerator = 0;
    let morphemes = new Map();
    let lemma;
    readline.on('line', (l: string) => {
      let arr = l.trim().split(' ');
      let [morpheme, tag] = arr;
      if (!l.startsWith(' ')) {
        lemma = morpheme;
      }
      (morphemes[morpheme] = morphemes[morpheme] || []).push([
        lemmata[lemma] = lemmata[lemma] || lemmataIdGenerator++,
        tags[tag] = tags[tag] || tagsIdGenerator++
      ]);

    }).on('close', () => {
      lemmata = uniqValuedMap2array(lemmata);
      tags = uniqValuedMap2array(tags);
      resolve([lemmata, tags, morphemes]);
    });
  });
}


export function uniqValuedMap2array(map) {
    return Object.keys(map).sort((a, b) => {
        return map[a] - map[b];
    });
}


export class DawgInterprocess {
	private ipc = spawn('dawg-shell');
	
	constructor() {
		this.ipc.stdin.setEncoding('utf8');
	}

	keys(key: string): Promise<Array<string>> {
		return new Promise((resolve, reject) => {
			this.ipc.stdout.once('data', data => {
				if (data.indexOf('\n') === -1) {
					throw 'No newline in data';
				}
				resolve(JSON.parse(data));
			});
			
			this.ipc.stdin.write(key + '\n');
		})
	}
	
	close(): void {
		this.ipc.kill();
	}
}




enum NounType { common, proper }

enum Gender { masculine, feminine, neuter }
enum Case { nominative, genitive, dative, accusative, instrumental, locative, vocative }
enum Number_ { singular, dual, plural }
enum Person { first, second, third }
enum Tense { present, future, past }
enum Aspect { progressive, perfective }
enum VerbType { main, auxilary }
enum Mood { indicative, imperative, infinitive, impersonal }
enum Animacy { animate, inanimate }
enum Degree { positive, comparative, superlative }
enum Definiteness { short, full }



export class UdFeaturesBag {
  
}

////////////////////////////////////////////////////////////////////////////////
export function rysin2ud(lemma: string, lemmaTagStr: string, form: string, formTagStr: string) {
  let ret = new Array<{ pos: string, features: string }>();

  let lemmaTag = new RysinTag(lemmaTagStr);
  let formTag = new RysinTag(formTagStr);

  for (let pos of formTag.poses()) {
    // todo: treat special
    if (!skipMainPos(formTag)) {
      switch (formTag.pos) {
        case 'noun': {
          let isProper = startsWithCap(form);  // todo: abbrs
          
          break;
        }
        case 'verb': {
          
        }
        default:
          throw new Error(`Unexpected POS tag: '${formTag.pos}'`);
      }
    }
  }

  return ret;
}