////////////////////////////////////////////////////////////////////////////////
export async function rysinDict2Json(readline, output) {
  return new Promise(resolve => {
    let lemmata = {};
    let lemmataIdGenerator = 0;
    let tags = {};
    let tagsIdGenerator = 0;
    let morphemes = new Map();
    let lemma;
    readline.on('line', (l: string) => {
      let arr = l.trim().split(' ');
      let [morpheme, tag] = arr;
      if (!l.startsWith(' ')) {
        lemma = morpheme;
      }
      (morphemes[morpheme] = morphemes[morpheme] || []).push([
        lemmata[lemma] = lemmata[lemma] || lemmataIdGenerator++,
        tags[tag] = tags[tag] || tagsIdGenerator++
      ]);

    }).on('close', () => {
      lemmata = uniqValuedMap2array(lemmata);
      tags = uniqValuedMap2array(tags);
      resolve([lemmata, tags, morphemes]);
    });
  });
}


export function uniqValuedMap2array(map) {
    return Object.keys(map).sort((a, b) => {
        return map[a] - map[b];
    });
}


export class DawgInterprocess {
	private ipc = spawn('dawg-shell');
	
	constructor() {
		this.ipc.stdin.setEncoding('utf8');
	}

	keys(key: string): Promise<Array<string>> {
		return new Promise((resolve, reject) => {
			this.ipc.stdout.once('data', data => {
				if (data.indexOf('\n') === -1) {
					throw 'No newline in data';
				}
				resolve(JSON.parse(data));
			});
			
			this.ipc.stdin.write(key + '\n');
		})
	}
	
	close(): void {
		this.ipc.kill();
	}
}


